Please create a python 3 unittest script
based on the following structure,
with a test function for each comment, 
and the same kind of syntax that the first example 'test_instantiation' :
"
#!/usr/bin/python3

import unittest
from models.amenity import Amenity

class TestAmenity(unittest.TestCase):
    """
    Test class for Amenity class
    """

    def setUp(self):
        self.amenity_data = {
            'name': 'Wifi',
            'description': 'Fast internet connection'
        }
        self.amenity = Amenity.create(self.amenity_data)

    def test_instantiation(self):
        """Check if the instantiation of amenity object works properly"""
        self.assertIsInstance(self.amenity, Amenity)
        self.assertEqual(self.amenity.name, 'Wifi')
        self.assertEqual(self.amenity.description, 'Fast internet connection')

# Check if the ID ALWAYS stays the same

# Check if created_at is set during creation of a new amenity
# and stays the same

# Check if updated_at is set during edition of the amenity 

# Creating an amenity with an empty name

# Creating an amenity with a real name 
# “Wifi”

# Creating an amenity with a wrong name

# Editing the name of the amenity to a valid name
# "Wifi" => "Swimming Pool"

# Editing the name of the amenity to an invalid name

# Creating a valid description for an amenity
#"Big Swimming Pool with a floating dolphin"

# Editing a description for an amenity

# Removing a description

# Removing an amenity

if __name__ == "__main__":
    unittest.main()
"

And here is the file the unittest is testing :
"
import uuid
from datetime import datetime
from .crud import CRUD

class Amenity(CRUD):
    storage = {}

    def __init__(self, name, description):
        if not isinstance(name, str):
            raise TypeError("name must be a string")
        if not isinstance(description, str):
            raise TypeError("description must be a string")
        if not name:
            raise ValueError("name cannot be empty")

        self.id = str(uuid.uuid4())
        self.name = name
        self.description = description
        self.created_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()

    def __repr__(self):
        return f"<Amenity {self.name}>"

    @classmethod
    def create(cls, data):
        amenity = Amenity(**data)
        Amenity.storage[amenity.id] = amenity
        return amenity

    @classmethod
    def read(cls, id):
        return cls.storage.get(id)

    @classmethod
    def update(cls, id, data):
        amenity = cls.storage.get(id)
        if amenity:
            for key, value in data.items():
                if hasattr(amenity, key):
                    if key == 'name' and not isinstance(value, str):
                        raise TypeError(f"{key} must be a string")
                    if key == 'name' and not value:
                        raise ValueError("name cannot be empty")
                    if key == 'description' and not isinstance(value, str):
                        raise TypeError(f"{key} must be a string")
                    setattr(amenity, key, value)
            amenity.updated_at = datetime.utcnow()
            return amenity
        return None

    @classmethod
    def delete(cls, id):
        return cls.storage.pop(id, None)
"